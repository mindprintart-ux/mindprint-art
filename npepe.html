<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mindprint Filler Engine</title>
  <link rel="icon" href="favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <meta name="theme-color" content="#0b0d12">
  <meta property="og:title" content="Negative Pepe ‚Äî mindprint.art">
  <meta property="og:description" content="High-contrast negative variant.">
  <meta property="og:image" content="https://mindprint.art/og.png">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://mindprint.art/npepe.html">
  <meta property="og:site_name" content="mindprint.art">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://mindprint.art/og.png">
  <link rel="canonical" href="https://mindprint.art/npepe.html">
  <style>
    :root{ --bg:#0a0a0a; --panel:#111318; --ink:#000; --paper:#fff; --accent:#82e2ff; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:
        radial-gradient(1000px 600px at 20% -10%, rgba(130,226,255,.12), transparent 45%),
        radial-gradient(800px 500px at 85% 0%, rgba(130,226,255,.06), transparent 40%),
        repeating-linear-gradient(60deg, hsla(200, 90%, 65%, .08) 0 2px, transparent 2px 18px),
        repeating-linear-gradient(-30deg, hsla(300, 90%, 70%, .06) 0 1px, transparent 1px 16px),
        repeating-linear-gradient(120deg, hsla(160, 90%, 60%, .05) 0 1px, transparent 1px 14px),
        var(--bg);
      background-attachment: fixed;
      color:#e7e7e7;
      font:14px/1.6 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      text-rendering:optimizeLegibility;
      text-align:center;
      animation:bg-drift 18s ease-in-out infinite alternate;
      padding:16px;
    }
    @media (prefers-reduced-motion: reduce){ body{animation:none} }
    @keyframes bg-drift{
      from{background-position:0 0, 100% 0, 0 0, 0 0, 0 0, 0 0}
      to{background-position:0 -120px, 100% -80px, 200px 0, -180px 0, 120px 0, 0 0}
    }
    h1{margin:0 0 8px 0;font-size:18px;letter-spacing:.2px}
    canvas{
      background:#111;margin-top:10px;border-radius:14px;
      box-shadow:0 10px 32px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.06);
    }
    button{
      appearance:none;margin:.5em;padding:8px 14px;font-size:14px;
      color:#fff;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.15);border-radius:10px;cursor:pointer;
      transition:transform .15s ease,border-color .15s ease,box-shadow .15s ease,background .15s ease;
    }
    button:hover{border-color:rgba(255,255,255,.28);box-shadow:0 6px 18px rgba(0,0,0,.35)}
    button:active{transform:translateY(1px)}
    button:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(130,226,255,.25);border-color:rgba(130,226,255,.5)}
  </style>
</head>
<body>
  <h1>mindprint.art ‚Äì Opepen Grid-Aligned Generator</h1>
  <!-- Wallet connect removed -->
  <canvas id="mindprint" width="768" height="768"></canvas>
  <br>
  <button onclick="generateArt()">üîÅ Regenerate</button>
  <button onclick="downloadPNG()">üì• Export PNG</button>
  <button onclick="downloadSVG()">üì• Export SVG (outline only)</button>
  <button onclick="downloadHighResPNG()">üì∏ Export High-Res PNG (2500x2500)</button>

  <script>
    const canvas = document.getElementById("mindprint");
    const ctx = canvas.getContext("2d");
    const unit = 96;

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawSolidColor(x, y, w, h, color = "#FFD700") {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);
    }

    function drawDiagonalStripes(x, y, w, h, color = "white") {
      ctx.save();
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.clip();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      for (let i = -w; i < w + h; i += 10) {
        ctx.beginPath();
        ctx.moveTo(x + i, y);
        ctx.lineTo(x + i + h, y + h);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawNoiseFill(x, y, w, h) {
      const imageData = ctx.createImageData(w, h);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const val = Math.random() * 255;
        imageData.data[i] = val;
        imageData.data[i + 1] = val;
        imageData.data[i + 2] = val;
        imageData.data[i + 3] = 100;
      }
      ctx.putImageData(imageData, x, y);
    }

    function drawDotGrid(x, y, w, h, spacing = 12) {
      ctx.fillStyle = "white";
      for (let i = x + spacing / 2; i < x + w; i += spacing) {
        for (let j = y + spacing / 2; j < y + h; j += spacing) {
          ctx.beginPath();
          ctx.arc(i, j, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawRadialBurst(x, y, w, h) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1.2;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.clip();
      for (let i = 0; i < 100; i++) {
        const angle = (Math.PI * 2 * i) / 100;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * w, cy + Math.sin(angle) * h);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawConcentricCircles(x, y, w, h) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1.5;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.clip();
      for (let r = 10; r < Math.min(w, h) / 1.2; r += 10) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawWaves(x, y, w, h) {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1.2;
      ctx.save();
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.clip();
      for (let j = y; j < y + h; j += 8) {
        ctx.beginPath();
        for (let i = x; i < x + w; i++) {
          const wave = Math.sin(i * 0.05 + j * 0.1) * 6;
          ctx.lineTo(i, j + wave);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    const traitFunctions = [
      drawSolidColor,
      drawDiagonalStripes,
      drawNoiseFill,
      drawDotGrid,
      drawRadialBurst,
      drawConcentricCircles,
      drawWaves
    ];

    function drawRandomTrait(x, y, w, h) {
      const trait = traitFunctions[Math.floor(Math.random() * traitFunctions.length)];
      trait(x, y, w, h);
    }

    function drawBaseOpepen() {
      drawRandomTrait(unit * 2, unit * 1, unit * 2, unit * 2); // Left Eye
      drawRandomTrait(unit * 4, unit * 1, unit * 2, unit * 2); // Right Eye
      drawRandomTrait(unit * 2, unit * 3, unit * 4, unit * 2); // Mouth
      drawRandomTrait(unit * 2, unit * 6, unit * 4, unit);     // Lower Bar
    }

    function generateArt() {
      clearCanvas();
      drawBaseOpepen();
    }

    function downloadPNG() {
      const link = document.createElement('a');
      link.download = 'mindprint.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function downloadHighResPNG() {
      const scale = 2500 / 768;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 2500;
      tempCanvas.height = 2500;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.scale(scale, scale);
      drawBaseOpepenOnContext(tempCtx);
      const link = document.createElement('a');
      link.download = 'mindprint-highres.png';
      link.href = tempCanvas.toDataURL('image/png');
      link.click();
    }

    function drawBaseOpepenOnContext(customCtx) {
      const u = 96;
      const traits = [
        traitFunctions[Math.floor(Math.random() * traitFunctions.length)],
        traitFunctions[Math.floor(Math.random() * traitFunctions.length)],
        traitFunctions[Math.floor(Math.random() * traitFunctions.length)],
        traitFunctions[Math.floor(Math.random() * traitFunctions.length)]
      ];
      traits[0](customCtx, u * 2, u * 1, u * 2, u * 2);
      traits[1](customCtx, u * 4, u * 1, u * 2, u * 2);
      traits[2](customCtx, u * 2, u * 3, u * 4, u * 2);
      traits[3](customCtx, u * 2, u * 6, u * 4, u);
    }

    function downloadSVG() {
      const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
        <svg xmlns="http://www.w3.org/2000/svg" width="768" height="768" viewBox="0 0 768 768">
          <rect x="192" y="96" width="192" height="192" fill="#FFD700" />
          <rect x="384" y="96" width="192" height="192" fill="none" stroke="white" stroke-width="2" stroke-dasharray="10 5" />
          <rect x="192" y="288" width="384" height="192" fill="gray" fill-opacity="0.2" />
          <rect x="192" y="576" width="384" height="96" fill="none" stroke="white" stroke-width="1" />
        </svg>`;
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const link = document.createElement('a');
      link.download = 'mindprint.svg';
      link.href = URL.createObjectURL(blob);
      link.click();
    }

    generateArt();
  </script>
  <!-- Wallet connect code removed -->
</body>
</html>
