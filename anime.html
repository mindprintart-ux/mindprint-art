<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mindprint Filler Engine</title>
  <style>
    body { background: #000; color: #fff; font-family: sans-serif; text-align: center; }
    canvas { background: #111; margin-top: 1em; border-radius: 12px; }
    button { margin: 0.5em; padding: 8px 16px; font-size: 16px; }
  </style>
</head>
<body>
  <h1>mindprint.art ‚Äì Opepen Grid-Aligned Generator</h1>
  <canvas id="mindprint" width="768" height="768"></canvas>
  <br>
  <button id="regenerate">üîÅ Regenerate</button>
  <button onclick="downloadGIF()">üéû Export Animated GIF</button>

  <script src="https://unpkg.com/gif.js.optimized/dist/gif.js"></script>
  <script>
    const canvas = document.getElementById("mindprint");
    const ctx = canvas.getContext("2d");
    const unit = 96;
    let frame = 0;

    const traitFunctions = [
      drawNoiseFill,
      drawDotGrid,
      drawRadialBurst,
      drawConcentricCircles,
      drawWaves,
      drawDiagonalStripes,
    ];

    function getRandomColor() {
      const palette = ["#ffffff", "#00ffff", "#ff00ff", "#ffff00", "#00ff00", "#ff9900", "#ff0033", "#33ccff"];
      return palette[Math.floor(Math.random() * palette.length)];
    }

    function getRandomTraitFn() {
      const trait = traitFunctions[Math.floor(Math.random() * traitFunctions.length)];
      const color = getRandomColor();
      return (x, y, w, h, frame) => {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        trait(x, y, w, h, frame);
        ctx.restore();
      };
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    let activeTraits = [];

    function applyTraitToClip(x, y, w, h, clipFn, traitFns = [getRandomTraitFn()]) {
      activeTraits.push({ x, y, w, h, clipFn, traitFns });
    }

    function renderTraits() {
      clearCanvas();
      for (const { x, y, w, h, clipFn, traitFns } of activeTraits) {
        ctx.save();
        clipFn();
        ctx.clip();
        for (let i = 0; i < traitFns.length; i++) {
          traitFns[i](x, y, w, h, frame);
        }
        ctx.restore();
      }
    }

    function drawNoiseFill(x, y, w, h, frame = 0) {
      const imageData = ctx.createImageData(w, h);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const val = Math.random() * 255;
        imageData.data[i] = val;
        imageData.data[i + 1] = val;
        imageData.data[i + 2] = val;
        imageData.data[i + 3] = 100;
      }
      ctx.putImageData(imageData, x, y);
    }

    function drawDotGrid(x, y, w, h) {
      for (let i = x + 6; i < x + w; i += 12) {
        for (let j = y + 6; j < y + h; j += 12) {
          ctx.beginPath();
          ctx.arc(i, j, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawRadialBurst(x, y, w, h, frame = 0) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      const count = 40;
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * (i + frame / 5)) / count;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * w, cy + Math.sin(angle) * h);
        ctx.stroke();
      }
    }

    function drawConcentricCircles(x, y, w, h) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      for (let r = 10; r < Math.min(w, h) / 1.2; r += 10) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function drawWaves(x, y, w, h, frame = 0) {
      for (let j = y; j < y + h; j += 8) {
        ctx.beginPath();
        for (let i = x; i < x + w; i++) {
          const wave = Math.sin(i * 0.05 + j * 0.1 + frame * 0.05) * 6;
          ctx.lineTo(i, j + wave);
        }
        ctx.stroke();
      }
    }

    function drawDiagonalStripes(x, y, w, h) {
      for (let i = -w; i < w + h; i += 10) {
        ctx.beginPath();
        ctx.moveTo(x + i, y);
        ctx.lineTo(x + i + h, y + h);
        ctx.stroke();
      }
    }

    function drawBaseOpepen() {
      activeTraits = [];

      const eyeX = unit * 2;
      const eyeY = unit * 1;

      // LEFT EYE corrected 3 arcs + 1 square inside the 2x2 block
      applyTraitToClip(eyeX, eyeY, unit, unit, () => {
        ctx.beginPath();
        ctx.rect(eyeX, eyeY, unit, unit);
        ctx.closePath();
      });

      applyTraitToClip(eyeX + unit, eyeY, unit, unit, () => {
        ctx.beginPath();
        ctx.moveTo(eyeX + unit * 2, eyeY);
        ctx.arc(eyeX + unit, eyeY, unit, -Math.PI / 2, 0);
        ctx.closePath();
      });

      applyTraitToClip(eyeX + unit, eyeY + unit, unit, unit, () => {
        ctx.beginPath();
        ctx.moveTo(eyeX + unit * 2, eyeY + unit * 2);
        ctx.arc(eyeX + unit, eyeY + unit, unit, 0, Math.PI / 2);
        ctx.closePath();
      });

      applyTraitToClip(eyeX, eyeY + unit, unit, unit, () => {
        ctx.beginPath();
        ctx.moveTo(eyeX, eyeY + unit * 2);
        ctx.arc(eyeX, eyeY + unit, unit, Math.PI / 2, Math.PI);
        ctx.closePath();
      });

      // RIGHT EYE
      const quadrants = [
        { angleStart: 0, angleEnd: Math.PI / 2 },
        { angleStart: Math.PI / 2, angleEnd: Math.PI },
        { angleStart: Math.PI, angleEnd: 3 * Math.PI / 2 },
        { angleStart: 3 * Math.PI / 2, angleEnd: Math.PI * 2 },
      ];
      quadrants.forEach(({ angleStart, angleEnd }) => {
        const clipFn = () => {
          ctx.beginPath();
          ctx.moveTo(unit * 5, unit * 2);
          ctx.arc(unit * 5, unit * 2, unit, angleStart, angleEnd);
          ctx.closePath();
        };
        applyTraitToClip(unit * 4, unit * 1, unit * 2, unit * 2, clipFn, [getRandomTraitFn()]);
      });

      // MOUTH
      applyTraitToClip(unit * 2, unit * 3, unit * 4, unit * 2, () => {
        ctx.beginPath();
        ctx.moveTo(unit * 2, unit * 3);
        ctx.lineTo(unit * 6, unit * 3);
        ctx.lineTo(unit * 6, unit * 5 - 24);
        ctx.quadraticCurveTo(unit * 6, unit * 5, unit * 6 - 24, unit * 5);
        ctx.lineTo(unit * 2 + 24, unit * 5);
        ctx.quadraticCurveTo(unit * 2, unit * 5, unit * 2, unit * 5 - 24);
        ctx.lineTo(unit * 2, unit * 3);
        ctx.closePath();
      });

      // LOWER BAR
      applyTraitToClip(unit * 2, unit * 6, unit * 4, unit, () => {
        ctx.beginPath();
        ctx.moveTo(unit * 2, unit * 7);
        ctx.lineTo(unit * 6, unit * 7);
        ctx.lineTo(unit * 6, unit * 6 + 24);
        ctx.quadraticCurveTo(unit * 6, unit * 6, unit * 6 - 24, unit * 6);
        ctx.lineTo(unit * 2 + 24, unit * 6);
        ctx.quadraticCurveTo(unit * 2, unit * 6, unit * 2, unit * 6 + 24);
        ctx.lineTo(unit * 2, unit * 7);
        ctx.closePath();
      });
    }

    function generateArt() {
      drawBaseOpepen();
    }

    function downloadGIF() {
      const gif = new GIF({ workers: 2, quality: 10, width: 768, height: 768 });
      for (let i = 0; i < 20; i++) {
        renderTraits();
        gif.addFrame(ctx, { copy: true, delay: 100 });
        frame++;
      }
      gif.on('finished', function(blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'mindprint.gif';
        link.click();
      });
      gif.render();
    }

    document.getElementById("regenerate").addEventListener("click", generateArt);

    function loop() {
      renderTraits();
      frame++;
      requestAnimationFrame(loop);
    }

    generateArt();
    loop();
  </script>
</body>
</html>
